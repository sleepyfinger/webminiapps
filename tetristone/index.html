<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TetriStone</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
        font-family: "Arial", sans-serif;
      }

      h1 {
        font-size: 2.5rem;
        text-align: center;
        margin-bottom: 0;
      }

      #version {
        font-size: 0.9rem;
        color: #888;
        text-align: center;
        margin-top: 0;
        margin-bottom: 20px;
        font-weight: normal;
        font-style: italic;
      }

      #copyright {
        font-size: 0.7rem;
        color: #888;
        text-align: center;
        margin-top: 10px;
        font-weight: normal;
      }

      #game-container {
        border: 2px solid #333;
        border-radius: 10px;
        background-color: #fff;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        position: relative;
        overflow: hidden;
      }

      #restart-button {
        padding: 10px 20px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 18px;
        transition: background-color 0.3s;
      }

      #restart-button:hover {
        background-color: #45a049;
      }

      #game-over-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 10;
      }

      #game-over-text {
        font-size: 36px;
        color: white;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      #mobile-controls {
        display: flex;
        justify-content: center;
        width: 100%;
        padding: 10px 0;
        background-color: #f0f0f0;
        position: relative;
        bottom: 0;
        left: 0;
      }

      #mobile-controls button {
        font-size: 24px;
        padding: 15px 20px;
        margin: 0 10px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }

      #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 100%;
        padding: 20px;
      }

      #score-container {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 10px;
      }

      @media (max-width: 720px) {
        #game-wrapper {
          transform: scale(0.8);
        }
      }
    </style>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  </head>
  <body>
    <div id="game-wrapper">
      <h1 id="title">TetriStone</h1>
      <p id="version">ver 0.1</p>
      <div id="score-container">Score: <span id="score">0</span></div>
      <div id="game-container">
        <div id="game-over-container">
          <div id="game-over-text">Game Over</div>
          <button id="restart-button">Retry</button>
        </div>
      </div>
      <div id="mobile-controls">
        <button id="left-btn">←</button>
        <button id="right-btn">→</button>
        <button id="rotate-btn">↻</button>
        <button id="down-btn">↓</button>
      </div>
      <p id="copyright">Created by SleepyFinger.</p>
    </div>

    <script>
      const ROWS = 20;
      const COLS = 10;
      const BLOCK_SIZE = 30;
      const COLORS = [
        0xff0000, // Red
        0x00ff00, // Green
        0x0000ff, // Blue
        0xffff00, // Yellow
        0x00ffff, // Cyan
        0xff00ff, // Magenta
      ];

      const SHAPES = [
        [
          [[1, 2, 3, 4]],
          [[1], [2], [3], [4]],
          [[4, 3, 2, 1]],
          [[4], [3], [2], [1]],
        ],
        [
          [
            [1, 2],
            [4, 3],
          ],
          [
            [4, 1],
            [3, 2],
          ],
          [
            [3, 4],
            [2, 1],
          ],
          [
            [2, 3],
            [1, 4],
          ],
        ],
        [
          [
            [1, 2, 3],
            [0, 4, 0],
          ],
          [
            [0, 1],
            [4, 2],
            [0, 3],
          ],
          [
            [0, 4, 0],
            [3, 2, 1],
          ],
          [
            [3, 0],
            [2, 4],
            [1, 0],
          ],
        ],
        [
          [
            [1, 2, 3],
            [4, 0, 0],
          ],
          [
            [4, 1],
            [0, 2],
            [0, 3],
          ],
          [
            [0, 0, 4],
            [3, 2, 1],
          ],
          [
            [3, 0],
            [2, 0],
            [1, 4],
          ],
        ],
        [
          [
            [1, 2, 3],
            [0, 0, 4],
          ],
          [
            [0, 1],
            [0, 2],
            [4, 3],
          ],
          [
            [4, 0, 0],
            [3, 2, 1],
          ],
          [
            [3, 4],
            [2, 0],
            [1, 0],
          ],
        ],
        [
          [
            [1, 2, 0],
            [0, 3, 4],
          ],
          [
            [0, 1],
            [3, 2],
            [4, 0],
          ],
          [
            [4, 3, 0],
            [0, 2, 1],
          ],
          [
            [0, 4],
            [2, 3],
            [1, 0],
          ],
        ],
        [
          [
            [0, 2, 1],
            [4, 3, 0],
          ],
          [
            [4, 0],
            [3, 2],
            [0, 1],
          ],
          [
            [0, 3, 4],
            [1, 2, 0],
          ],
          [
            [1, 0],
            [2, 3],
            [0, 4],
          ],
        ],
      ];

      class Piece {
        constructor(scene, shape) {
          this.scene = scene;
          this.shapeSet = shape;
          this.shapeIndex = 0;
          this.shape = this.shapeSet[this.shapeIndex];
          this.x = Math.floor(COLS / 2) - Math.ceil(this.shape[0].length / 2);
          this.y = 0;
          this.blocks = [];
          this.createBlocks();
        }

        createBlocks() {
          this.shape.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value !== 0) {
                const color = COLORS[value - 1];
                const block = this.scene.add
                  .rectangle(
                    (this.x + x) * BLOCK_SIZE + BLOCK_SIZE / 2,
                    (this.y + y) * BLOCK_SIZE + BLOCK_SIZE / 2,
                    BLOCK_SIZE - 2,
                    BLOCK_SIZE - 2,
                    color
                  )
                  .setOrigin(0.5);
                block.setStrokeStyle(2, 0x000000);
                block.color = color;
                this.blocks.push(block);
              }
            });
          });
        }

        moveDown() {
          this.y++;
          this.updateBlockPositions();
          if (this.collision()) {
            this.y--;
            this.updateBlockPositions();
            this.lock();
            return true;
          }
          return false;
        }

        moveLeft() {
          this.x--;
          this.updateBlockPositions();
          if (this.collision()) {
            this.x++;
            this.updateBlockPositions();
          }
        }

        moveRight() {
          this.x++;
          this.updateBlockPositions();
          if (this.collision()) {
            this.x--;
            this.updateBlockPositions();
          }
        }

        rotate() {
          const prevShapeIndex = this.shapeIndex;
          this.shapeIndex = (this.shapeIndex + 1) % this.shapeSet.length;
          this.shape = this.shapeSet[this.shapeIndex];
          this.updateBlockPositions();

          if (this.collision()) {
            this.shapeIndex = prevShapeIndex;
            this.shape = this.shapeSet[this.shapeIndex];
            this.updateBlockPositions();
          } else {
            this.updateBlockColors();
          }
        }

        updateBlockColors() {
          let blockIndex = 0;
          this.shape.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value !== 0) {
                if (blockIndex < this.blocks.length) {
                  const color = COLORS[value - 1];
                  this.blocks[blockIndex].fillColor = color;
                  this.blocks[blockIndex].color = color;
                }
                blockIndex++;
              }
            });
          });
        }

        updateBlockPositions() {
          let blockIndex = 0;
          this.shape.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value !== 0) {
                if (blockIndex < this.blocks.length) {
                  this.blocks[blockIndex].x =
                    (this.x + x) * BLOCK_SIZE + BLOCK_SIZE / 2;
                  this.blocks[blockIndex].y =
                    (this.y + y) * BLOCK_SIZE + BLOCK_SIZE / 2;
                }
                blockIndex++;
              }
            });
          });
        }

        collision() {
          return this.shape.some((row, dy) =>
            row.some(
              (value, dx) =>
                value !== 0 &&
                (this.y + dy < 0 ||
                  this.y + dy >= ROWS ||
                  this.x + dx < 0 ||
                  this.x + dx >= COLS ||
                  board[this.y + dy][this.x + dx] !== 0)
            )
          );
        }

        lock() {
          this.shape.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value !== 0) {
                if (this.y + y < 0) {
                  this.scene.gameOver();
                } else {
                  const block = this.blocks.find((block) => {
                    const blockX = (this.x + x) * BLOCK_SIZE + BLOCK_SIZE / 2;
                    const blockY = (this.y + y) * BLOCK_SIZE + BLOCK_SIZE / 2;
                    return block.x === blockX && block.y === blockY;
                  });
                  if (block) {
                    board[this.y + y][this.x + x] = block.color;
                  }
                }
              }
            });
          });
          this.blocks.forEach((block) => {
            block.destroy();
          });
          this.blocks = [];
          this.scene.checkLines();
          this.scene.checkColorMatches();
        }

        hardDrop() {
          while (!this.moveDown()) {}
        }
      }

      function random(array) {
        return array[Math.floor(Math.random() * array.length)];
      }

      let board;
      let score = 0;
      let currentPiece;
      let scoreElement;
      let restartButton;
      let gameOverContainer;

      class GameScene extends Phaser.Scene {
        constructor() {
          super({ key: "GameScene" });
        }

        preload() {}

        create() {
          board = Array(ROWS)
            .fill()
            .map(() => Array(COLS).fill(0));
          score = 0;
          scoreElement = document.getElementById("score");
          restartButton = document.getElementById("restart-button");
          gameOverContainer = document.getElementById("game-over-container");

          this.updateScore();
          currentPiece = new Piece(this, random(SHAPES));

          this.input.keyboard.on("keydown-LEFT", () => currentPiece.moveLeft());
          this.input.keyboard.on("keydown-RIGHT", () =>
            currentPiece.moveRight()
          );
          this.input.keyboard.on("keydown-DOWN", () => currentPiece.moveDown());
          this.input.keyboard.on("keydown-UP", () => currentPiece.rotate());
          this.input.keyboard.on("keydown-SPACE", () =>
            currentPiece.hardDrop()
          );
          this.dropCounter = 0;
          this.dropInterval = 500;
          this.isGameOver = false;

          restartButton.addEventListener("click", () => {
            this.scene.restart();
            gameOverContainer.style.display = "none";
          });

          document
            .getElementById("left-btn")
            .addEventListener("click", () => currentPiece.moveLeft());
          document
            .getElementById("right-btn")
            .addEventListener("click", () => currentPiece.moveRight());
          document
            .getElementById("rotate-btn")
            .addEventListener("click", () => currentPiece.rotate());
          document
            .getElementById("down-btn")
            .addEventListener("click", () => currentPiece.hardDrop());
        }

        update(time, delta) {
          if (this.isGameOver) return;
          this.dropCounter += delta;
          if (this.dropCounter > this.dropInterval) {
            if (currentPiece.moveDown()) {
              currentPiece = new Piece(this, random(SHAPES));
              if (currentPiece.collision()) {
                this.gameOver();
              }
            }
            this.dropCounter = 0;
          }
          this.drawBoard();
        }

        checkLines() {
          let lines = 0;
          for (let y = ROWS - 1; y >= 0; y--) {
            if (board[y].every((value) => value !== 0)) {
              lines++;
              board.splice(y, 1);
              board.unshift(Array(COLS).fill(0));
            }
          }
          if (lines > 0) {
            score += lines * 100;
            this.updateScore();
          }
        }

        checkColorMatches() {
          const directions = [
            [0, 1],
            [1, 0],
            [1, 1],
            [-1, 1],
          ];
          let matched = [];
          for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
              if (board[y][x] !== 0) {
                directions.forEach(([dx, dy]) => {
                  let length = 1;
                  let nx = x + dx,
                    ny = y + dy;

                  while (
                    ny >= 0 &&
                    ny < ROWS &&
                    nx >= 0 &&
                    nx < COLS &&
                    board[ny][nx] === board[y][x]
                  ) {
                    length++;
                    nx += dx;
                    ny += dy;
                  }
                  if (length >= 3) {
                    for (let i = 0; i < length; i++) {
                      if (
                        !matched.find(
                          (match) =>
                            match.x === x + i * dx && match.y === y + i * dy
                        )
                      ) {
                        matched.push({ x: x + i * dx, y: y + i * dy });
                      }
                    }
                  }
                });
              }
            }
          }

          matched.forEach((match) => {
            board[match.y][match.x] = 0;
          });

          if (matched.length > 0) {
            score += matched.length * 50;
            this.updateScore();
          }
        }

        updateScore() {
          scoreElement.textContent = `${score}`;
        }

        drawBoard() {
          this.children.each((child) => {
            if (child.name === "boardBlock") {
              child.destroy();
            }
          });

          board.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value !== 0) {
                const block = this.add
                  .rectangle(
                    x * BLOCK_SIZE + BLOCK_SIZE / 2,
                    y * BLOCK_SIZE + BLOCK_SIZE / 2,
                    BLOCK_SIZE,
                    BLOCK_SIZE,
                    value
                  )
                  .setOrigin(0.5)
                  .setName("boardBlock");
                block.setStrokeStyle(2, 0x000000);
              }
            });
          });
        }

        gameOver() {
          this.isGameOver = true;
          gameOverContainer.style.display = "flex";
        }
      }

      const config = {
        type: Phaser.AUTO,
        width: COLS * BLOCK_SIZE,
        height: ROWS * BLOCK_SIZE,
        parent: "game-container",
        scene: [GameScene],
      };

      const game = new Phaser.Game(config);
    </script>
  </body>
</html>
